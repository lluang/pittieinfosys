---
title: 'Lab 12: Simulation'
author: "IE 0015 Information Systems"
date: "April 12-13, 2018"
output: 
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(magrittr)
library(tidyr)
library(ggplot2)
```

## 1. Monte Carlo simulation

You want to using Monte Carlo simulation to find the volume of an ellipsoid defined by:

$$\frac{x^2}{4^2} + \frac{y^2}{6^2} + \frac{z^2}{3^2}\leq1$$

a.  What are the values of three semi-principle axis of the ellipsoid? (the distance from the center to the edges that )
b.  Define a 3-d rectangular box that completely encloses the ellipsoid.  Find the volume of that box.
c.  Write a simulation that uses Monte Carlo to estimate the volume of the ellipsoid.
d.  Run the simulation for 10,000 iterations 10 times (i.e. find 10 estimates of the volume)
e.  Calculate the 95% confidence interval of the volume. (Note: see section 8.1 of *Introduction to R* in the Help section. The function you need is qt). You may have to reference your IE 1071 book/notes or the IPSUR book (from the ISPUR package).

**ANSWER**

a. Axis are 4, 6, 3
b. Ellipsoid is inside the box formed by x from -4 to 4, y from -6 to 6, z from -3 to 3. Note that the total volume is 
```{r}
2 * 4 * 2 * 6 * 2 * 3
```

c. Simulation of volume of ellipsoid with 10000 samples.

```{r}
reps = 10
maxx = 4
maxy = 6
maxz = 3
ellipsevolume <- function(a, b, c){
  boxvolume = 2*a * 2 *b * 2*c
  maxi = 10000
  x <- runif(maxi, min = -a, max = a)
  y <- runif(maxi, min = -b, max = b)
  z <- runif(maxi, min = -c, max = c)
  inellipse <- ifelse((x^2)/(a^2) + (y^2)/(b^2) + (z^2)/(c^2) <= 1, 1.0, 0.0)
  volume <- mean(inellipse) * boxvolume
  volume
}
```
d. Run simulation 10 replications
```{r}
reps = 10
volumeellipse <- replicate(reps, ellipsevolume(maxx, maxy, maxz))
volumeellipse
```
e. Calculate 95\% confidence interval based on 10 replications
```{r}
meanvolume <- mean(volumeellipse)
sdvolume <- sd(volumeellipse)
paste(meanvolume, sdvolume)
```

```{r}
alpha =0.05
meanvolume + qt((1-alpha/2), df=(reps-1)) * sdvolume/sqrt(reps)
meanvolume - qt((1-alpha/2), df=(reps-1)) * sdvolume/sqrt(reps)
```
Note: the correct formula for the volume is

$$V = \frac{4}{3} \Pi * A * B * C$$
```{r}
4/3*pi * maxx * maxy * maxz
```

## 1. Hypothesis testing (4 points)

Assisted Reproductive Technology (ART) is a collection of techniques that help facilitate pregnancy (e.g. in vitro fertilization). A 2008 report by the Centers for Disease Control and Prevention estimated that ART has been successful in leading to a live birth in 31\% of cases. A new fertility clinic claims that their success rate is higher than average. A random sample of 30 of their patients yielded a success rate of 40\%. 
A consumer watchdog group would like to determine if this provides strong evidence to support the company's claim.

a. [1] Write the hypothesis ($H0$ and $HA$) to test if the success rate for ART at this clinic is significantly higher than the success rate reported by the CDC.
b. [1] Write a simulation that models the null hypothesis.
c.  [1] Run the simulation 10,000 times and plot the result.
d.  [1] Estimate the p-value of the clinic's result and evaluate the claim that the clinic's success rate is higher than average.


**ANSWER**
a.  H0:  p = 0.31
    HA:  p > 0.31
    
b.

In the simulation, sample 30 times where p= 0.31 (the null hypothesis is generated from the general population).
Count the success rate for each sample of 30.
Repeat this 10,000 times.
From histogram, find phat = 40
The p-value is the tail probability at phat = 0.40.

```{r}
clinicsim <- function(i){
              successes <- sum(sample(x=0:1, size = 30, replace=TRUE, prob=c((1-0.31), 0.31)))
              return = successes/30
}
```

c. Run simulation and plot result

```{r}
clinicresults <-sapply(1:10000, clinicsim)
```

or

```{r}
clinicresults <-  replicate(10000, clinicsim(1))
```

```{r}
hist(clinicresults, main="ART success rate", xlab="Fraction success")
```

d.  Calculate the p-value

```{r}
print(length(clinicresults[clinicresults>0.40])/length(clinicresults))
```

This is the p-value, so compare this against a target p-value (usually 0.05).  Because you do not reject the null hypothesis, this result does not support the claim that the clinic success rate is higher than average.

# 3 Scheduling problem (6 points)

A shop processes jobs through a single machine.  Currently, the shop runs on a First-in First-out basis, where orders are completed in the order they arrive.  However, there are a large number of late jobs (which are handled through expediting which leads to large amounts of Work In Progress). Evaluate some alternative scheduling rules using bootstrap simulation.

```{r}
job <- data.frame(job = c(1, 2,3, 4, 5, 6, 7, 8), 
                  processingtime = c(2, 3, 2, 1, 4, 3, 4, 2),
                  duedate = c(7, 3, 11, 5, 13, 10, 15, 17))
```

a. [2] You want to generate through bootstrapping a large number of simulated days.  Write a function that takes the current jobs, then samples from that eight jobs (with replacement), and assigns them randomly sampled due dates from the historical data (WITHOUT replacement).  Run this one time to prove that it works.

b. [2] Write functions that implement the following scheduling strategies and calculates the total lateness (time past due that an order is completed).  Apply this to the same example created in (a). Hint: use `arrange` to sort the orders:
    i. First-in First-out
    ii.  Earliest Due date first (sequence orders in order of due date, ties settled using shortest processing time first).
    iii.  Shortest processing time (sequence orders in order of processing time, with ties settled with earliest due date first).
    
c. [2] Simulate each method 50 times.  Show the results using a plot that shows variance. (remember to add titles and labels)  Which is the best in reducing lateness.


```{r}
lateness <- function(duedate, completiondate){
  lateness <- max(0, completiondate - duedate)
}
```

**ANSWER**

```{r 2a}
jobnumber <- sample(job$job, size = 8, replace = FALSE)
jobsim <- data.frame(job = jobnumber,
                     processingtime = job$processingtime[jobnumber], 
                     duedate = sample(job$duedate, size=8, replace = FALSE))


```

```{r 2b}
fifosort <- job
eddsort <- job %>% arrange(duedate, processingtime)
sptsort <- job %>% arrange(processingtime,duedate)
fifolate <- function(joblist){
   joblength <- length(joblist$job)
   totallateness <- 0
   completion <- 0
   for(i in 1:joblength){
     completion <- completion + joblist$processingtime[i]
     totallateness <- totallateness + lateness(joblist$duedate, completion)
   } 
   totallateness
}

eddlate <- function(joblist){
   joblength <- length(joblist$job)
   sortedd <- joblist %>% arrange(duedate, processingtime)
   totallateness <- 0
   completion <- 0
   for(i in 1:joblength){
     completion <- completion + sortedd$processingtime[i]
     totallateness <- totallateness + lateness(sortedd$duedate, completion)
   } 
   totallateness
}

sptlate <- function(joblist){
   joblength <- length(joblist$job)
   sortspt <- joblist %>% arrange(processingtime, duedate)
   totallateness <- 0
   completion <- 0
   for(i in 1:joblength){
     completion <- completion + sortspt$processingtime[i]
     totallateness <- totallateness + lateness(sortspt$duedate, completion)
   } 
   totallateness
}
```

```{r}
print("original lateness")
print(fifolate(job))
print(eddlate(job))
print(sptlate(job))
print("lateness of sampled order")
print(fifolate(jobsim))
print(eddlate(jobsim))
print(sptlate(jobsim))
```

```{r 2c}

fifolatesim <- c()
eddlatesim <- c()
sptlatesim <- c()
set.seed(1234)
for (t in 1:50){
  jobnumber <- sample(job$job, size = 8, replace = TRUE)
  jobsim <- data.frame(job = jobnumber,
                     processingtime = job$processingtime[jobnumber], 
                     duedate = sample(job$duedate, size=8, replace = FALSE))
  fifolatesim <- c(fifolatesim, fifolate(jobsim))
  eddlatesim <- c(eddlatesim, eddlate(jobsim))
  sptlatesim <- c(sptlatesim, sptlate(jobsim))
}
```
```{r 2c results}
latesimresults <- data.frame(FIFO = fifolatesim, 
                              EDD = eddlatesim,
                              SPT =  sptlatesim)
ggplot(latesimresults) + geom_boxplot(aes(x="FIFO", y=FIFO)) + geom_boxplot(aes(x="EDD", y=EDD)) + geom_boxplot(aes(x="SPT", y=SPT)) +
  ylab("Total delay in completion") + ylim(0, 100) + xlab("Scheduling rule") +
  ggtitle("Lateness by scheduling rule")
```

Same thing, but use gather to collect results into a single column and with a violin plot instead of box and whiskers.

```{r}
# Alternative way of creating graph
latesimresults %>% 
  gather(key=rule, value=lateness, FIFO, EDD, SPT) %>%
  ggplot() + geom_violin(aes(x=rule, y=lateness)) + 
  ylab("Total delay in completion") + ylim(0, 100) + xlab("Scheduling rule") +
  ggtitle("Lateness by scheduling rule")
```