Module 6: Summarizing data (plyr)
========================================================
author: Yuwen Yang
date: 

Mean, Variance
========================================================

mean(x, ...), Var(x, ...)

Default S3 method:


Examples
========================================================

x <- c(0:10, 50)

xm <- Var(x)

c(xm, mean(x, trim = 0.10))

Sample Quantiles
========================================================
The generic function quantile produces sample quantiles corresponding to the given probabilities. The smallest observation corresponds to a probability of 0 and the largest to a probability of 1.

Usage
========================================================

quantile(x, ...)

Default S3 method:

quantile(x, probs = seq(0, 1, 0.25), na.rm = FALSE,
         names = TRUE, type = 7, ...)

Box and whiskers
========================================================
The upper and lower "hinges" correspond to the first and third quartiles (the 25th and 75th percentiles). This differs slightly from the method used by the boxplot function, and may be apparent with small samples.

Usage
========================================================

geom_boxplot(mapping = NULL, data = NULL, stat = "boxplot",

  position = "dodge", outlier.colour = NULL, outlier.shape = NULL,

  outlier.size = NULL, notch = FALSE, notchwidth = 0.5,

  varwidth = FALSE, ...)

plyr: the split-apply-combine paradigm for R.
========================================================

a set of clean and consistent tools that implement the split-apply-combine pattern in R

- breaking it down into small pieces
- doing something to each piece
- combining the results back together again

Details
========================================================

named according to what sort of data structure they split up and what sort of data structure they return:

a: array

l: list

d: data.frame

m: multiple inputs

r: repeat multiple times

_: nothing



Details (continue)
========================================================

So:

- ddply takes a data frame as input and returns a data frame as output
- l_ply takes a list as input and returns nothing as output

ddply {plyr}
========================================================

For each subset of a data frame, apply function then combine results into a data frame

- ddply(.data, .variables, .fun = NULL, ..., .progress = "none",
  .inform = FALSE, .drop = TRUE, .parallel = FALSE, .paropts = NULL)

Input & Output
========================================================

Input

- This function splits data frames by variables.

Output

- The most unambiguous behaviour is achieved when .fun returns a data frame - in that case pieces will be combined with rbind.fill. If .fun returns an atomic vector of fixed length, it will be rbinded together and converted to a data frame. Any other values will result in an error.

If there are no results, then this function will return a data frame with zero rows and columns (data.frame()).

Example
========================================================

```{r, echo = FALSE}
pregcolnames <- c("CASEID", "pregordr", "HOWPREG_N", "HOWPREG_P", 
"moscurrp", "NOWPRGDK", "PREGEND1", "PREGEND2", 
"PREGEND3", "HOWENDDK", "NBRNALIV", "MULTBRTH", 
"bornaliv", "DATPRGEN_M", "DATPRGEN_Y", "cmotpreg", 
"AGEATEND", "GESTASUN_M", "GESTASUN_W", "wksgest", 
"mosgest", "DK1GEST", "DK2GEST", "DK3GEST", 
"bpa_bdscheck1", "bpa_bdscheck2", "bpa_bdscheck3", "BABYSEX1", 
"BIRTHWGT_LB1", "BIRTHWGT_OZ1", "LOBTHWGT1", "BABYSEX2", 
"BIRTHWGT_LB2", "BIRTHWGT_OZ2", "LOBTHWGT2", "BABYSEX3", 
"BIRTHWGT_LB3", "BIRTHWGT_OZ3", "LOBTHWGT3", "BABYDOB_M", 
"BABYDOB_Y", "cmbabdob", "kidage", "HPAGELB", 
"BIRTHPLC", "PAYBIRTH1", "PAYBIRTH2", "PAYBIRTH3", 
"PAYBIRTH4", "CSECPRIM", "CSECMED1", "CSECMED2", 
"CSECMED3", "CSECMED4", "CSECMED5", "CSECPLAN", 
"KNEWPREG", "TRIMESTR", "LTRIMEST", "PRIORSMK", 
"POSTSMKS", "NPOSTSMK", "GETPRENA", "BGNPRENA", 
"PNCTRIM", "LPNCTRI", "WORKPREG", "WORKBORN", 
"DIDWORK", "MATWEEKS", "WEEKSDK", "MATLEAVE", 
"LIVEHERE1", "ALIVENOW1", "WHENDIED_M1", "WHENDIED_Y1", 
"cmkidied1", "WHENLEFT_M1", "WHENLEFT_Y1", "cmkidlft1", 
"lastage1", "WHERENOW1", "LEGAGREE1", "PARENEND1", 
"ANYNURSE1", "FEDSOLID1", "FRSTEATD_N1", "FRSTEATD_P1", 
"FRSTEATD1", "QUITNURS1", "AGEQTNUR_N1", "AGEQTNUR_P1", 
"AGEQTNUR1", "LIVEHERE2", "ALIVENOW2", "WHENDIED_M2", 
"WHENDIED_Y2", "cmkidied2", "WHENLEFT_M2", "WHENLEFT_Y2", 
"cmkidlft2", "lastage2", "WHERENOW2", "LEGAGREE2", 
"PARENEND2", "ANYNURSE2", "FEDSOLID2", "FRSTEATD_N2", 
"FRSTEATD_P2", "FRSTEATD2", "QUITNURS2", "AGEQTNUR_N2", 
"AGEQTNUR_P2", "AGEQTNUR2", "LIVEHERE3", "ALIVENOW3", 
"WHENDIED_M3", "WHENDIED_Y3", "cmkidied3", "WHENLEFT_M3", 
"WHENLEFT_Y3", "cmkidlft3", "lastage3", "WHERENOW3", 
"LEGAGREE3", "PARENEND3", "ANYNURSE3", "FEDSOLID3", 
"FRSTEATD_N3", "FRSTEATD_P3", "FRSTEATD3", "QUITNURS3", 
"AGEQTNUR_N3", "AGEQTNUR_P3", "AGEQTNUR3", "prgoutcome", 
"outcom_s", "nbrnlv_s", "cmprgend", "cmendp_s", 
"cmprgbeg", "cmpbeg_s", "cmlastlb", "cmlstprg", 
"cmfstprg", "cmpg1beg", " cmintstr", 
"cmintfin", "cmintstrop", "cmintfinop", "cmintstrcr", 
"cmintfincr", "anyusint", "EVUSEINT", "STOPDUSE", 
"WHYSTOPD", "WHATMETH01", "WHATMETH02", "WHATMETH03", 
"WHATMETH04", "RESNOUSE", "WANTBOLD", "PROBBABE", 
"CNFRMNO", "WANTBLD2", "TIMINGOK", "TOOSOON_N", 
"TOOSOON_P", "WTHPART1", "WTHPART2", "FEELINPG", 
"HPWNOLD", "TIMOKHP", "COHPBEG", "COHPEND", 
"TELLFATH", "WHENTELL", "TRYSCALE", "WANTSCAL", 
"WHYPRG1", "WHYPRG2", "WHYNOUSE1", "WHYNOUSE2", 
"WHYNOUSE3", "WHYNOUSE4", "WHYNOUSE5", "MAINOUSE", 
"PRGLNGTH", "OUTCOME", "BIRTHORD", "DATEND", 
"AGEPREG", "DATECON", "AGECON", "FMAROUT5", 
"PMARPREG", "RMAROUT6", "FMARCON5", "RMARCON6", 
"LEARNPRG", "PNCAREWK", "PAYDELIV", "LBW1", 
"LIVCHILD", "BFEEDWKS", "MATERNLV", "OLDWANTR", 
"OLDWANTP", "WANTRESP", "WANTPART",
"cmbirth", "AGER", "agescrn", "FMARITAL", 
"RMARITAL", "EDUCAT", "HIEDUC", "RACE", 
"HISPANIC", "HISPRACE", "HISPRACE2", "RCURPREG", 
"PREGNUM", "PARITY", "CURR_INS", "PUBASSIS", 
"POVERTY", "LABORFOR", "RELIGION", "METRO", 
"BRNOUT", "yrstrus", "PRGLNGTH_I", "OUTCOME_I", 
"BIRTHORD_I", "DATEND_I", "AGEPREG_I", "DATECON_I", 
"AGECON_I", "FMAROUT5_I", "PMARPREG_I", "RMAROUT6_I", 
"FMARCON5_I", "RMARCON6_I", "LEARNPRG_I", "PNCAREWK_I", 
"PAYDELIV_I", "LBW1_I", "LIVCHILD_I", "BFEEDWKS_I", 
"MATERNLV_I", "OLDWANTR_I", "OLDWANTP_I", "WANTRESP_I", 
"WANTPART_I", "AGER_I", "FMARITAL_I", "RMARITAL_I", 
"EDUCAT_I", "HIEDUC_I", "RACE_I", "HISPANIC_I", 
"HISPRACE_I", "HISPRACE2_I", "RCURPREG_I", "PREGNUM_I", 
"PARITY_I", "CURR_INS_I", "PUBASSIS_I", "POVERTY_I", 
"LABORFOR_I", "RELIGION_I", "METRO_I", "FINALWGT30", 
"WGTQ1Q16", "WGTQ9Q16", "WGTQ5Q16", "WGTQ1Q8", 
"SECU", "SEST", "cmintvw", "cmlstyr", 
"cmjan3yr", "cmjan5yr", "questyear", "Quarter", "Phase" ) 

pregcolwidths = 
  c(5, 2, 2, 1, 6, 1, 1, 1, 1, 1, 
    1, 1, 1, 2, 4, 4, 2, 2, 2, 2, 
    2, 1, 1, 1, 1, 1, 1, 1, 2, 2, #55
    1, 1, 2, 2, 1, 1, 1, 2, 1, 2, 
    4, 4, 3, 2, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 2, 1, 1, 1, #99
    1, 1, 1, 2, 1, 1, 1, 1, 1, 2, #111
    1, 2, 1, 1, 2, 4, 4, 2, 4, #132
    4, 3, 1, 1, 1, 1, 1, 3, 1, 2, #150
    1, 3, 1, 2, 1, 1, 2, 4, 4, 2, 
    4, 4, 3, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 2, 1, 2, 1, 1, 1, 4, 4, 1, #208
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 2, 1, 2, 1, 1, 1, 4, 4, #236
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, #284
    1, 1, 1, 1, 2, 2, 2, 2, 
    1, 1, 1, 1, 1, 1, 3, #305
    1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 
    2, 2, 1, 1, 2, 1, 1, 1, 1, 2, 2,  #332
    1, 2, 4, 4, 4, 4, 1, 1, 1, 1, 1, #356
    2, 2, 1, 1, 1, 3, 1, 1, 1, 1, #370
    1, 4, 2, 2, 1, 1, 2, 2, #385
    1, 1, 1, 1, 1, 2, 2, 1, 1, 3, #399
    1, 1, 1, 1, 4, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, #448
    18, 18, 18, 18, 18, 
    1, 3, 4, 4, 4, 4, 1, 2, 1 ) #562
```


```{r}
# Summarize a dataset by two variables
require(plyr)
FemPreg <- read.fwf("data/2006_2010_FemPreg.dat",
         widths = pregcolwidths,
         col.names = pregcolnames)

# Note the use of the '.' function to allow
# BABYSEX1 and PRGLNGTH to be used without quoting
Babysex_summary<-ddply(FemPreg, .(BABYSEX1, PRGLNGTH), summarize,

# Calculate mean and sd for each BABYSEX1 AND PRGLNGTH
 mean = round(mean(BIRTHWGT_OZ1), 2),
 sd = round(sd(BIRTHWGT_OZ1), 2))

# Plot charts of the result
plot(mean ~ BABYSEX1, type = "p", data = Babysex_summary)
plot(mean ~ PRGLNGTH, type = "b", data = Babysex_summary)


```

Slide With Plot
========================================================

```{r, echo=FALSE}
plot(mean ~ BABYSEX1, type = "p", data = Babysex_summary)
```

Slide With Plot
========================================================

```{r, echo=FALSE}
plot(mean ~ PRGLNGTH, type = "b", data = Babysex_summary)
```



l_ply {plyr}
========================================================

For each element of a list, apply function and discard results

Usage
========================================================

l_ply(.data, .fun = NULL, ..., .progress = "none", .inform = FALSE,
  .print = FALSE, .parallel = FALSE, .paropts = NULL)

Input & Output
========================================================

Input

- This function splits lists by elements.

Output

- All output is discarded. This is useful for functions that you are calling purely for their side effects like displaying plots or saving output.

Row names
========================================================

- no plyr function will preserve row names - in general it is too hard to know what should be done with them for many of the operations supported by plyr
- If you want to preserve row names, use name_rows to convert them into an explicit column in your data frame, perform the plyr operations, and then use name_rows again to convert the column back into row names.

Helpers
========================================================

Plyr also provides a set of helper functions for common data analysis problems:

- arrange: re-order the rows of a data frame by specifying the columns to order by
- mutate: add new columns or modifying existing columns, like transform, but new columns can refer to other columns that you just created
- summarise: like mutate but create a new data frame, not preserving any columns in the old data frame.
- join: an adapation of merge which is more similar to SQL, and has a much faster implementation if you only want to find the first match.

Helpers (continue)
========================================================

Plyr also provides a set of helper functions for common data analysis problems:

- match_df: a version of join that instead of returning the two tables combined together, only returns the rows in the first table that match the second.

- colwise: make any function work colwise on a dataframe

- rename: easily rename columns in a data frame

- round_any: round a number to any degree of precision

- count: quickly count unique combinations and return return as a data frame

