---
title: 'Lecture 8: Character Manipulation and Strings'
author: "IE 0015"
date: "February 2020"
output:
  html_document:
    df_print: paged
  pdf_document: default
  slidy_presentation: default
---

Introduction
=============

- You should load the titanic and Rime of the Ancient Marinere from the Courseweb datasets.
- You should have the `stringr` package

```{r}
library(tidyr)
library(dplyr)
library(magrittr)
library(stringr)
```

4V's - Volume
===============

- Volume - How many rows/records there are.  Order of magnitude matters
    -  You can inspect every record.  Usually up to a few hundred lines
    -  Not practical to inspect every record.  Few thousand lines.
    -  Too large for Excel.  Either beyond your Excel skills or beyond the limits of Excel capabilities.  In IE we see this a few senior projects each semester.
    -  Processing time (in a programming language such as R or Python) becomes non-trivial.
    -  Too large to fit in a desktop/laptop computer memory.  Require RAID memory storage and parallel processing capability to do this in a practical amount of time.

4V's - Variety
=================

- The diversity in the data (columns) that you have.  Examples:
    -  Demographic
    -  Size
    -  Financial
    -  Performance
    -  Schedule
    -  Test results
    -  Biological
    -  Chemical composition
    -  Physical properties
    -  Time logs
    

4V's - Velocity
=================

-  Change over time. 
-  Consider if seasonality matters.
-  Does the environment of the data collection change over the course of the dataset
-  Do policies and procedures change over the course of the dataset
-  Is there anything else that changes how the data elements are collected:
    -  Different processes being recorded
    -  Different product mix being produced
    -  New and non-comperable groups of people
    
4V's - Veracity
================

-  What can cause the data to be inaccurate?
-  Do responders have incentive to lie or hide from data collection?
-  Do data collectors have a standard definition of data elements?
-  Is there a recognized official repository of confirmed data?
-  Is there an official arbitrator of data elements (e.g. a referee or umpire)?
-  Note: the data repository, unless it is an official repository, is not a guarantor of data accuracy.
-  Note: the fact that a government agency is a repository, is not a guarantee, unless they are also in the position of being a referee or they are declaring themselves to be an official repository (i.e. regulatory agency)


CoNVO
=========

-  **Co**ntext.  Hypothetical client's overall goal
-  **N**eeds.  A decision the client needs to make and a data question that needs to be answered.
-  **V**ision. How the question will be answered.  A sketch of a possible chart.
-  **O**utcome. Some choices the client can make.
  
Project extra credit
====================

- Use a method/package we do not cover in class or in the course textbooks.
- Value: one letter grade on project (can go over 100)
- Implication: you will have to learn it on your own. I will help you find materials and guide you.
- Some possible methods that have shown up in past projects:
    - Mapping/geo data
    - Differential equations
    - Linear algebra
    - Anything from other IE/Pitt classes (I can help find a useful package)
    - Text mining
    - Time series/forecasting

Working with Characters
==================== 
                                                                        
-  For computers, working with numbers is easy.
-  Working with strings is harder.
-  Things to do
  -  Extract substrings
  -  Combine strings
  -  Match strings
  -  Search and replace
  
What this course is not covering in class
======================

- This course is not covering
  - Text mining
  - Text analysis
  - e.g. what Google, Amazon.com, etc. do
- If your project requires it:
  - Text mining with R 
    - http://tidytextmining.com/
    - This book is written in the same spirit as R for Data Science.
  - `tm` package in R
    - The package vignette is a good introduction to text mining and methods of text analysis
    - https://cran.r-project.org/web/packages/tm/vignettes/tm.pdf

Basics of working with characters
==================

-  Character strings act much like arrays.
-  They can be sorted, determine length, etc.
-  The functions working with characters can be vectorized.
  - If you apply a function to a vector (array/data frame) it is applied to all members of that vector and the result is a vector.

```{r}
head(state.name)
length(state.name)
str_length(state.name)
```

Quotes and escapes
==================

- The pair of double quote ("") or single quotes('') mark strings.
- For consistency, always use double quotes unless you need nested quotes.
- Note that you need to use `writeLines` to not show escape characters.

```{r}
string1 <- "This is a string"
string2 <- 'If I want to include a "quote" inside a string, I use single quotes'
print(string1)
print(string2)
writeLines(string2)
```

Common mistakes
=================
- Not closing a quote

```
"This is a string without a quote
```

-  Look at the console, see the '+' character
-  Close the string using a `"`

Escape characters
===================

- Some character sequences are special (e.g. ")
- To remove their special meaning, use the backslash as an *escape* character (\)
```{r}
double_quote <- "\"" # or '"'
single_quote <- '\'' # or "'"
```
- If you need a backslash (e.g. identifying a file directory path), use a double backslash
```
filelocation = "C:\Documents\courses"
```
- Generates an error 
```
Error: '\D' is an unrecognized escape in character string starting ""C:\D"
```

```
filelocation = "C:\\Documents\\courses"
```

Combining (concatenating) strings
==============

-  You can join strings
-  You can also combine variable values with strings
-  Specify how to separate strings using the `sep` parameter.

```{r}
cat("Long strings can", "be displayed over", "several lines using", "the fill= arguement", sep = " ", fill = 40)
```

`str_c` is the preferred alternative to `cat`
=================

- Works when you need to convert other data types to strings
- Also better when you have to do operations to generate strings.
- The rest of the lecture, I will avoid using non-`stringr` methods.

```{r}
str_c('one', 2, 'three', 4, 'five')
```
- Add the *sep* argument to separate them (other than tabs)
- Add the *collapse* argument to combine them into a single string.

```{r}
str_c(c('X', 'Y'), 1:6, sep="_")
str_c(c('X', 'Y'), 1:6, sep="_", collapse="|")
```

Use *str_c* To combine strings
=========================

```{r}
str_c("x", "y", "z")
str_c("x", "y", "z", sep=",")
```

Working with substrings
================

-  Computers treat strings like arrays, so getting a substring is like using indices of arrays.
-  Look at *help(str_sub)* to see arguments for *str_sub* (start, end)

```{r}
str_sub(state.name[1:5], 1, 4)
al = str_sub(state.name[1], start=1:str_length(state.name[1]), end=1:str_length(state.name[1]))
al
which(al=="a")
```

Replacing texts
==========

- We can use the *str_sub* function to replace strings if we find them
- Note that it overwrites the characters
    - If you want to insert, use *sub_c*

```{r}
nickname = "Sweet Home"
str_sub(state.name[1], 4, 4+nchar(nickname))=nickname
state.name[1]
``` 

Searches and Regular expressions
========

What are regular expressions?
===============

-  Regular expressions are ways of encoding patterns for matching sets of strings.
-  Find *x*
-  Find *x* but only if it occurs after *y*
-  Match *x*, but *x* can be written in many formats

Example - Phone numbers
======================

- How do you write a North American 10-digit phone number?
- e.g. 412-624-9830

Lets look for sets of digits
================

- `[0-9]` represents any character between 0 and 9, inclusive.
- *between* is based on the ASCII character set.
- Note that in RStudio, the *Find* bar includes a check box for *Regex*

With great power comes complexity
========================

-  Regular expressions attempts to be able to represent any type of search that can be imaginable.
-  But that means it needs to be able to represent very complex logic, and the results are complicated.
-  This is an example of a Domain Specific Language (DSL)

Preliminaries
========================

- Wildcards can match anything  ('.', '*')
- Backslashes ('\\') can be used to specify or ignore special behavior (e.g. I had to use two \ to represent one \ in between the quote marks in this sentence)
- References to *Perl* - A computer language whose main use was in working with text data. Includes an enhanced version of Regular Expressions from the POSIX standard. Use when available.

Basics
========

Regular expressions have three components

1.  literal characters
2.  character classes
3.  modifiers

Backslashes can be used to turn a modifier into a literal character.

Literal characters
=============

- Matched exactly

Character classes
=============

-  Letters [A-Z], [a-z], [A-Za-z]
-  Digits [0-9] [0123456789] `\d`
-  Alpha numeric  [:alnum:]
-  Other classes [ACTG]

Modifiers
===========

Modifier | Meaning |
-----|-----|
^ | beginning of target |
$ | end of target |
. | match any single character |
\| |  separates alternative patterns |
() | groups patterns together |
* | matches 0 or more of the preceding entity |
? | matches 0 or 1 of the preceding entity |
+ | matches 1 or more of the preceding entity |
{n} | matches exactly *n* occurrences of the preceding entity |
{n,} | matches at least *n* occurrences of the preceding entity |
{n, m} | matches between *n* and *m* occurrences of the preceding entity |

Examples
=========

- [0-9][0-9][a-zA-Z]+ has two digits followed by one or more letters.
- 12a 01Zd
- (abc){3} means abcabcabc
- [abc]{3} means three of 'a', 'b', 'c' in a row
- [0-9]{3} or \d{3} Any group of three digits
- `[\^0-9] \D`  Not a digit

Character classes
=========

-  *Character classes* also known as *conventions* have been created to express different groups of characters

-  `[\d]` refers to any digit. Same as [0-9]
-  `[\D]` is any non-digit. Same as `[\^0-9]` or `[\^\d]`
-  `[\w]` is any word character. Same as [_a-zA-Z0-9]
  - Does NOT include white space (tabs, new lines, punctuation)
-  `[\W]` is any non-word character (whitespace, punctuation, etc). Same as [\^_a-zA-Z0-9]
-  `[\s]` or `[ \t\n\r]` matches whitespace, or
  - spaces
  - `[\t]` tabs
  - `[\n]` newlines
  - `[\r]` carriage returns

Simple searches
================

- Simple searches can be literal

```{r}
bananas = c("banana", "Banana", "BANANA", "bananas")
str_view(bananas, "banana")
```
Upper and lower case
==============
```{r}
str_view(bananas, regex("banana", ignore_case=TRUE))
```

Anchors
========

- You can tell that a string needs to be at the beginning or end of the word using anchors
    - `^` for beginning of the word
    - `$` for the end of the word

```{r}
apples <- c("apple pie", "apple", "apple cake", "crabapple")
str_view(apples, "apple")
```

```{r}
str_view(apples, "^apple")
```

```{r}
str_view(apples, "apple$")
```

```{r}
str_view(apples, "^apple$")
```


Phone number
===========

- 412-624-9830
- (412)624-9838
- 412/624-9800
- 412-255-2621
- 412.624.9830
- `[\W]?[0-9]{3}[\W]?[0-9]{3}[\W]?[0-9]{4}`
  - Optional leading character not letter or number `[\W]`?
  - Three digits `[0-9]{3}`
  - One or more non-digit `[\W]`?
  - Three digits `[0-9]{3}`
  - Optional non-digit `[\W]`?
  - Four digits `[0-9]{4}`


Using stringr functions
=======================

-  *str_view* looks at a regular expression match
-  *str_view_all* finds all matches
-  Two arguments, the string, then the pattern

```{r}
x <- "1888 is the longest year in Roman numerals: MDCCCLXXXVIII"
str_view(x, "CC?")
```
```{r}
numbers <- c("412-624-9830", "(412)624-9838", "412/624-9800", "412-255-2621", "412.624.9830")
str_view_all(numbers, "[\\W]?[0-9]{3}[\\W]?[0-9]{3}[\\W]?[0-9]{4}")
```

Splitting strings
=================

-  We can split strings based on a character or a regular expression.

```{r}
str = 'one   two      three  four'
str_split(str, " ")
```

With regular expressions
==================

-  Use the one or more modifier '+' to say that any number of spaces will be a split

```{r}
str_split(str, " +")
```
- and make this a vector using `simplify` (which is usually easier to use than a list)
```{r}
str_split(str, " +", simplify = TRUE)
```


We can use it to find records in a data frame
================================

- `grep` takes a regular expression and a character string or vectors and returns either the indices or values (value=TRUE) of the matches
- `regexp`
- Example, find women who are not members of nobility.
- Mrs, Miss, Ms, Mme (Madame), Mlle (Mademoiselle) are generic title for women and girls
- Always followed by a period in this database
- Note that we need to *escape* the period using a backslash (\) or the regular expression will think that it is a wild card character
  -  And because we are passing a string in R, we need to escape the backslash with another backslash.

Titanic personal title example
=====
```{r loadtitanic, echo=FALSE}
titanic <- read.csv("../data/titanic3.csv")
```

```{r}
womentitanic <- (titanic[grep("Mrs.|Miss.|Ms.|Mme.|Mlle.",
                              titanic$name), 
                         'name'])
head(womentitanic)
length(womentitanic)
```


```{r}
data = titanic$name[5]
titlelocation = str_locate(data, ", [A-Z][a-z]*\\.")
title = str_sub(data, titlelocation[1]+2, titlelocation[2])
title
```

The Rime of the Ancient Mariner
==========================

The Rime of the Ancient Mariner, Coleridge (1798)
============

-  Copy this into a R-studio editor window and save to a file

```
THE RIME OF THE ANCYENT MARINERE, IN SEVEN PARTS.

ARGUMENT.

How a Ship having passed the Line was driven by Storms to the cold
Country towards the South Pole; and how from thence she made her course
to the tropical Latitude of the Great Pacific Ocean; and of the strange
things that befell; and in what manner the Ancyent Marinere came back to
his own Country.

I.

1      It is an ancyent Marinere,
2        And he stoppeth one of three:
3      "By thy long grey beard and thy glittering eye
4        "Now wherefore stoppest me?
```



Working with text within R
========================

-  Read text into a variable
-  Find regular expression patterns using `grep`

```{r}
rime.txt <- file("../data/rime-intro.txt")
rime <- scan(rime.txt, what=character(), sep='\n')
any(grep('ship',rime))
any(grep('Ship',rime))
any(grep('[Ss]hip',rime))
```

Using str_view
==============
```{r}
str_view(rime, '[Ss]hip')
```
```{r}
str_locate(rime, '[Ss]hip')
```

```{r}
str_sub(rime[3], 7, 10)
```
Better will be to find all examples and where they are
=====================

-  `str_locate()` finds the first match in each section of the text.
-  `str_locate_all()` finds all matches in each section of text.

```{r}
findmarinere <- str_locate(rime, 'Marinere')
findmarinere
```
```{r}
findtheall <- str_locate_all(rime, 'the')
findtheall
```



Examples of using character classes in R
=========

-  Note the double backslash. First backslash is to tell R that the second one is real and not an escape sequence.

```{r}
str_locate(rime, '\\d') %>% tail()
```
```{r}
str_locate(rime, '\\D') %>% tail()
```
```{r}
str_locate(rime, '\\w') %>% head()
```
```{r}
str_locate(rime, '\\W') %>% head()
```
```{r}
str_locate(rime, '[A-Z]') %>% tail()
```


Alternatives
==================

- What if you wanted to match alternative spellings?
- '|' is used to separate alternatives

```{r}
str_locate(rime, '[t|T][h|H][e|E]') %>% head()
```
```{r}
str_locate(rime, '(the|The)') %>% head()
```
More character classes
==================

```{r}
characters = "! \" # $ % & ' ( ) * + , - . /
0       1       2       3       4       5       6       7       8       9
: ; < = > ? @
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
[ \ ] ^ _ `
a b c d e f g h i j k l m n o p q r s t u v w x y z
{ | } ~"
```

Look for a specific class
============
```{r}
str_locate_all(characters, "[aeiou]") %>% head()
```

Or everything else using ^
==============
```{r}
str_locate_all(characters, "[^aeiou]") %>% head()
```

Try groups of characters
=====================

```{r}
str_locate_all(characters, "[0-3]") 
```
```{r}
str_locate_all(characters, "[6-9]") 
```

Combine them
=====
```{r}
str_locate(characters, "[0-36-9]")
```