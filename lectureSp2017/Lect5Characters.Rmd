---
title: "Character Manipulation and Regular Expressions"
author: "IE 0015"
date: "January 2017"
output:
  pdf_document: default
  slidy_presentation: default
  word_document: default
---
```{r}
library(tidyverse)
```

Working with Characters
==================== 
                                                                        
-  For computers, working with numbers is easy.
-  Working with strings is harder.
-  Things to do
  -  Extract substrings
  -  Combine strings
  -  Match strings
  -  Search and replace
  
What this course is not covering in class
======================

- This course is not covering
  - Text mining
  - Text analysis
  - e.g. what Google, Amazon.com, etc. do
- If your project requires it:
  - Text mining with R 
    - http://tidytextmining.com/
    - This book is written in the same spirit as R for Data Science.
  - `tm` package in R
    - The package vignette is a good introduction to text mining and methods of text analysis
    - https://cran.r-project.org/web/packages/tm/vignettes/tm.pdf
  
Basics of working with characters
==================

-  Character strings act much like arrays.
-  They can be sorted, determine length, etc.
-  The functions working with characters can be vectorized.
  - If you apply a function to a vector (array/data frame) it is applied to all members of that vector and the result is a vector.

```{r}
head(state.name)
length(state.name)
nchar(state.name)
```

Combining (concatenating) strings
==============

-  You can join strings
-  You can also combine variable values with strings
-  Specify how to separate strings using the `sep` parameter.

```{r}
cat("Long strings can", "be displayed over", "several lines using", "the fill= arguement", 
    sep = " ", fill = 40)
```

`paste` is a alternative to `cat`
=================

- Works when you need to convert other data types to strings
- Also better when you have to do operations to generate strings.

```{r}
paste(c('one', 2, 'three', 4, 'five'), 
      collapse = " ")
paste('X', 1:5, sep="")
paste(c('X', 'Y'), 1:6, sep="_", collapse="|")
```

Working with substrings
================

-  Computers treat strings like arrays, so getting a substring is like using indices of arrays.

```{r}
substring(state.name[1:5], 1, 4)
al = substring(state.name[1],first=1:nchar(state.name[1]), last=1:nchar(state.name[1]))
al
which(al=="a")
```

Replacing texts
==========

- We can use the substring function to replace strings if we find them
- Note that it overwrites, not expands the string

```{r}
nickname = "Sweet Home"
substring(state.name[1], 4, 4+nchar(nickname))=nickname
state.name[1]
``` 


Regular expressions
========

What are regular expressions?
===============

-  Regular expressions are ways of encoding patterns for matching sets of strings.
-  Find *x*
-  Find *x* but only if it occurs after *y*
-  Match *x*, but *x* can be written in many formats

Example - Phone numbers
======================

- How do you write a North American 10-digit phone number?
- e.g. 412-624-9830

Lets look for sets of digits
================

- `[0-9]` represents any character between 0 and 9, inclusive.
- *between* is based on the ASCII character set.
- Note that in RStudio, the *Find* bar includes a check box for *Regex*

With great power comes complexity
========================

-  Regular expressions attempts to be able to represent any type of search that can be imaginable.
-  But that means it needs to be able to represent very complex logic, and the results are complicated.
-  This is an example of a Domain Specific Language (DSL)

Preliminaries
========================

- Wildcards can match anything  ('.', '*')
- Backslashes ('\\') can be used to specify or ignore special behavior (e.g. I had to use two \ to represent one \ in between the quote marks in this sentence)
- References to *Perl* - A computer language whose main use was in working with text data. Includes an enhanced version of Regular Expressions from the POSIX standard. Use when available.

Basics
========

Regular expressions have three components

1.  literal characters
2.  character classes
3.  modifiers

Backslashes can be used to turn a modifier into a literal character.

Literal characters
=============

-  Matched exactly

Character classes
=============

-  Letters [A-Z], [a-z], [A-Za-z]
-  Digits [0-9] [0123456789] `\d`
-  Alpha numeric  [:alnum:]
-  Other classes [ACTG]

Modifiers
===========

Modifier | Meaning |
-----|-----|
^ | beginning of target |
$ | end of target |
. | match any single character |
\| |  separates alternative patterns |
() | groups patterns together |
* | matches 0 or more of the preceding entity |
? | matches 0 or 1 of the preceding entity |
+ | matches 1 or more of the preceding entity |
{n} | matches exactly *n* occurrences of the preceding entity |
{n,} | matches at least *n* occurrences of the preceding entity |
{n, m} | matches between *n* and *m* occurrences of the preceding entity |

Examples
=========

- [0-9][0-9][a-zA-Z]+ has two digits followed by one or more letters.
- 12a 01Zd
- (abc){3} means abcabcabc
- [0-9]{3}  \d{3} Any group of three digits
- `[\^0-9] \D`  Not a digit

Character classes
=========

-  *Character classes* also known as *conventions* have been created to express different groups of characters

-  `[\d]` refers to any digit. Same as [0-9]
-  `[\D]` is any non-digit. Same as `[\^0-9]` or `[\^\d]`
-  `[\w]` is any word character. Same as [_a-zA-Z0-9]
  - Does NOT include white space (tabs, new lines, punctuation)
-  `[\W]` is any non-word character (whitespace, punctuation, etc). Same as [\^_a-zA-Z0-9]
-  `[\s]` or `[ \t\n\r]` matches whitespace, or
  - spaces
  - `[\t]` tabs
  - `[\n]` newlines
  - `[\r]` carriage returns

Phone number
===========

- 412-624-9830
- (412)624-9838
- 412/624-9800
- 412-255-2621
- 412.624.9830
- `[\W]?[0-9]{3}[\W]?[0-9]{3}[\W]?[0-9]{4}`
  - Optional leading character not letter or number `[\W]`?
  - Three digits `[0-9]{3}`
  - One or more non-digit `[\W]`?
  - Three digits `[0-9]{3}`
  - Optional non-digit `[\W]`?
  - Four digits `[0-9]{4}`


Splitting strings
=================

-  We can split strings based on a character or a regular expression.

```{r}
str = 'one   two      three  four'
strsplit(str, " ")
```

With regular expressions
==================

-  Use the one or more modifier '+' to say that any number of spaces will be a split

```{r}
strsplit(str, " +")
```

We can use it to find records in a data frame
================================

- *grep* takes a regular expression and a character string or vectors and returns either the indices or values (value=TRUE) of the matches
- Example, find women who are not members of nobility.
- Mrs, Miss, Ms, Mme (Madame), Mlle (Mademoiselle) are generic title for women and girls
- Always followed by a period in this database
- Note that we need to *escape* the period using a backslash (\) or the regular expression will think that it is a wild card character
  -  And because we are passing a string in R, we need to escape the backslash with another backslash.

Titanic personal title example
=====
```{r loadtitanic, echo=FALSE}
titanic <- read.csv("../data/titanictrain.csv")
```

```{r}
womentitanic <- (titanic[grep('Mrs\\.|Miss\\.|Ms\\.|Mme\\.|Mlle\\.',
                              titanic$Name), 
                         'Name'])
head(womentitanic)
length(womentitanic)
```

The Rime of the Ancient Mariner
==========================


The Rime of the Ancient Mariner, Coleridge (1798)
============

-  Copy this into a R-studio editor window and save to a file

```
THE RIME OF THE ANCYENT MARINERE, IN SEVEN PARTS.

ARGUMENT.

How a Ship having passed the Line was driven by Storms to the cold
Country towards the South Pole; and how from thence she made her course
to the tropical Latitude of the Great Pacific Ocean; and of the strange
things that befell; and in what manner the Ancyent Marinere came back to
his own Country.

I.

1      It is an ancyent Marinere,
2        And he stoppeth one of three:
3      "By thy long grey beard and thy glittering eye
4        "Now wherefore stoppest me?
```



Working with text within R
========================

-  Read text into a variable
-  Find regular expression patterns using `grep`

```{r}
rime.txt <- file("../data/rime-intro.txt")
rime <- scan(rime.txt, what=character(), sep='\n')
any(grep('ship',rime))
any(grep('Ship',rime))
any(grep('[Ss]hip',rime))
```

Better will be to find all examples and where they are
=====================

-  `regexpr` finds the first match in each section of the text.
-  `gregexpr` finds all matches in each section of text.

```{r}
regexprresult <- regexpr('Marinere', rime)
regexprresult  %>% head()
```
```{r}
gregexprresult <- gregexpr('Marinere', rime)
gregexprresult %>% head()
```



Examples of using character classes in R
=========

-  Note the double backslash. First backslash is to tell R that the second one is real and not an escape sequence.

```{r}
regexpr('\\d', rime) %>% head()
```
```{r}
gregexpr('\\D', rime) %>% head()
```
```{r}
gregexpr('\\w', rime) %>% head()
```
```{r}
regexpr('\\W', rime) %>% head()
```
```{r}
gregexpr('[A-Z]', rime) %>% head()
```


Alternatives
==================

- What if you wanted to match alternative spellings?
- '|' is used to separate alternatives

```{r}
regexpr('[t|T][h|H][e|E]', rime) %>% head()
gregexpr('(the|The|THE)', rime) %>% head()
```


More character classes
==================

```{r}
characters = "! \" # $ % & ' ( ) * + , - . /
0       1       2       3       4       5       6       7       8       9
: ; < = > ? @
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
[ \ ] ^ _ `
a b c d e f g h i j k l m n o p q r s t u v w x y z
{ | } ~"
```

Look for a specific class
============
```{r}
gregexpr("[aeiou]", characters) %>% head()
```

Or everything else using ^
==============
```{r}
gregexpr("[^aeiou]", characters) %>% head()
```


Try groups of characters
=====================

```{r}
gregexpr("[0-3]", characters) %>% head()
gregexpr("[6-9]", characters) %>% head()
```

Combine them
=====
```{r}
gregexpr("[0-36-9]", characters)  %>% head()
```
