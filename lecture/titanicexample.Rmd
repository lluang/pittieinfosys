---
title: "Titanic example"
author: "Louis Luangkesorn"
date: "12/31/2014"
output: html_document
---

Based on Curt Wehrley created another in-depth explanation of one approach to the Kaggle Titanic Getting Started example using R: github.com/wehrley/wehrley.github.io/blob/master/SOUPTONUTS.md


Read in the data from a directory.

```{r readdata}
readData <- function(path.name, file.name, column.types, missing.types) {
  read.csv( paste(path.name, file.name, sep="" ), 
            colClasses=column.types,
            na.strings=missing.types )
}

Titanic.path <- "/home/lluang/Documents/courses/DataScience/pittiedatascience2015/lectures/data"
train.data.file <- "titanictrain.csv"
test.data.file <- "test.csv"
missing.types <- c("NA", "")
train.column.types <- c('integer',   # PassengerId
                        'factor',    # Survived 
                        'factor',    # Pclass
                        'character', # Name
                        'factor',    # Sex
                        'numeric',   # Age
                        'integer',   # SibSp
                        'integer',   # Parch
                        'character', # Ticket
                        'numeric',   # Fare
                        'character', # Cabin
                        'factor'     # Embarked
)
test.column.types <- train.column.types[-2] 

train.raw <- readData(Titanic.path, train.data.file, 
                      train.column.types, missing.types)
df.train <- train.raw

test.raw <- readData(Titanic.path, test.data.file, 
                     test.column.types, missing.types)
df.infer <- test.raw 
```

Look at the data to see what values are missing

```{r missingvalues}
## map missing data by provided feature
require(Amelia)
missmap(df.train, main="Titanic Training Data - Missings Map", 
        col=c("yellow", "black"), legend=FALSE)
```

Missing Age values probably not a problem.  There are a lot of missing Cabin values.  Probably not usable, but we could revisit later.


Now let's visualize the data we do have.

```{r explorecharts}
barplot(table(df.train$Survived),
        names.arg = c("Perished", "Survived"),
        main="Survived (passenger fate)", col="black")
barplot(table(df.train$Pclass), 
        names.arg = c("first", "second", "third"),
        main="Pclass (passenger traveling class)", col="firebrick")
barplot(table(df.train$Sex), main="Sex (gender)", col="darkviolet")
hist(df.train$Age, main="Age", xlab = NULL, col="brown")
barplot(table(df.train$SibSp), main="SibSp (siblings + spouse aboard)", 
        col="darkblue")
barplot(table(df.train$Parch), main="Parch (parents + kids aboard)", 
        col="gray50")
hist(df.train$Fare, main="Fare (fee paid for ticket[s])", xlab = NULL, 
     col="darkgreen")
barplot(table(df.train$Embarked), 
        names.arg = c("Cherbourg", "Queenstown", "Southampton"),
        main="Embarked (port of embarkation)", col="sienna")
```

Does the class of the passenger make a difference?

```{r classsurvival}
mosaicplot(df.train$Pclass ~ df.train$Survived, 
           main="Passenger Fate by Traveling Class", shade=FALSE, 
           color=TRUE, xlab="Pclass", ylab="Survived")
```

Looks like it.

```{r survivalgender}
mosaicplot(df.train$Sex ~ df.train$Survived, 
           main="Passenger Fate by Gender", shade=FALSE, color=TRUE, 
           xlab="Sex", ylab="Survived")
```

So did gender.
How about age or port of embarkation?

```{r ageand port}
boxplot(df.train$Age ~ df.train$Survived, 
        main="Passenger Fate by Age",
        xlab="Survived", ylab="Age")
```

Age did not seem to matter, but port of embarkation seems to. Something to explore.

Let's look at all correlations
```{r correlationdiagram}
require(corrgram)
require(plyr)
corrgram.data <- df.train
## change features of factor type to numeric type for inclusion on correlogram
corrgram.data$Survived <- as.numeric(corrgram.data$Survived)
corrgram.data$Pclass <- as.numeric(corrgram.data$Pclass)
corrgram.data$Embarked <- revalue(corrgram.data$Embarked, 
                                  c("C" = 1, "Q" = 2, "S" = 3))
## generate correlogram
corrgram.vars <- c("Survived", "Pclass", "Sex", "Age", 
                   "SibSp", "Parch", "Fare", "Embarked")
corrgram(corrgram.data[,corrgram.vars], order=FALSE, 
         lower.panel=panel.ellipse, upper.panel=panel.pie, 
         text.panel=panel.txt, main="Titanic Training Data")
```


Can we do something about the age data?  Maybe think of using the average?

```{r averageage}
summary(df.train$Age)
```

Ok, that is too many missing, using the average would change the distribution.

```{r ageclass}
boxplot(df.train$Age ~ df.train$Pclass, 
        main="Passenger Class by Age",
        xlab="Passenger class", ylab="Age")
```

Can we get another clue about the ages of people?  Maybe if we looked at their names and relationships (because we have spouse, siblings, etc.)

```{r names}
head(df.train$Name, n=10L)
```

So, remember this is early 20th century.  *Miss* and *Master* are typically used for young girls and boys.  Now, lets turn that into a feature (column).

```{r gettitle}
getTitle <- function(data) {
  title.dot.start <- regexpr("\\,[A-Z ]{1,20}\\.", data$Name, TRUE)
  title.comma.end <- title.dot.start+ attr(title.dot.start, "match.length")-1
  data$Title <- substr(data$Name, title.dot.start+2, title.comma.end-1)
  return (data$Title)
}  
df.train$Title <- getTitle(df.train)
unique(df.train$Title)
```

Now let's see how many are missing by each title

```{r agetitle}
options(digits=2)
require(Hmisc)
bystats(df.train$Age, df.train$Title, 
        fun=function(x)c(Mean=mean(x),Median=median(x)))
```

Let's look at two of them

```{r agebytitle}
df.train$Age[which(df.train$Title=="Dr")]
df.train$Age[which(df.train$Title=="Master")]
```




To decide if this is good enough, think about how we will use the data. Because we are looking at children vs. non-children in survival, using the median ages for these groups is probably good.

```{r imputeages}
titles.na.train <- c("Dr", "Master", "Mrs", "Miss", "Mr")
imputeMedian <- function(impute.var, filter.var, var.levels) {
  for (v in var.levels) {
    impute.var[ which( filter.var == v)] <- impute(impute.var[ 
      which( filter.var == v)])
  }
  return (impute.var)
}
df.train$Age <- imputeMedian(df.train$Age, df.train$Title, 
                             titles.na.train)

df.train$Age[which(df.train$Title=="Dr")]
```

Let's repeat this for some other variables.

There was two NA for embarked, we can probably just substitute the most common embarkation point

```{r embarkedna}
df.train$Embarked[which(is.na(df.train$Embarked))] <- 'S'
```

How about fare?  Maybe particularly low fares were for children?

```{r checklowfares}
subset(df.train, Fare < 7)[order(subset(df.train, Fare < 7)$Fare, 
                          subset(df.train, Fare < 7)$Pclass), 
                          c("Age", "Title", "Pclass", "Fare")]
```

There is quite a diversity. So we probably think that the 0.0 fares are errors.  Let's use the median fare for that passenger class to replace the 0.0

```{r imputefares}
df.train$Fare[ which( df.train$Fare == 0 )] <- NA
df.train$Fare <- imputeMedian(df.train$Fare, df.train$Pclass, 
                              as.numeric(levels(df.train$Pclass)))
```

Let's look again at titles.  (Note that we're going to define a new one later)
```{r exploretitles}
df.train$Title <- factor(df.train$Title,
                         c("Capt","Col","Major","Sir","Lady","Rev",
                         "Dr","Don","Jonkheer","the Countess","Mrs",
                         "Ms","Mr","Mme","Mlle","Miss","Master", "Noble"))
boxplot(df.train$Age ~ df.train$Title, 
        main="Passenger Age by Title", xlab="Title", ylab="Age")
```

There are alot, many with few members.  Let's combine some.

```{r combinetitles}
## function for assigning a new title value to old title(s) 
changeTitles <- function(data, old.titles, new.title) {
  for (honorific in old.titles) {
    data$Title[ which( data$Title == honorific)] <- new.title
  }
  return (data$Title)
}
## Title consolidation
df.train$Title <- changeTitles(df.train, 
                               c("Capt", "Col", "Don", "Dr", 
                               "Jonkheer", "Lady", "Major", 
                               "Rev", "Sir", "the Countess"),
                               "Noble")
df.train$Title <- changeTitles(df.train, c("Ms"), 
                               "Mrs")
df.train$Title <- changeTitles(df.train, c("Mlle", "Mme"), "Miss")
df.train$Title <- as.factor(df.train$Title)

df.train$Title <- factor(df.train$Title,
                         c("Noble", "Mr", "Mrs", "Miss", "Master"))
boxplot(df.train$Age ~ df.train$Title, 
        main="Passenger Age by Title", xlab="Title", ylab="Age")
```

Now let's do some more data processing.  We can group families together to get fares per person, check for women and children first (dibs), identify the deck by cabin number, and check for port and starboard (based on the cabin number being even or odd).



```{r featureengineering}
require(plyr)     # for the revalue function 
require(stringr)  # for the str_sub function

## test a character as an EVEN single digit
isEven <- function(x) x %in% c("0","2","4","6","8") 
## test a character as an ODD single digit
isOdd <- function(x) x %in% c("1","3","5","7","9") 

## function to add features to training or test data frames
featureEngrg <- function(data) {
  ## Using Fate ILO Survived because term is shorter and just sounds good
  data$Fate <- data$Survived
  ## Revaluing Fate factor to ease assessment of confusion matrices later
  data$Fate <- revalue(data$Fate, c("1" = "Survived", "0" = "Perished"))
  ## Boat.dibs attempts to capture the "women and children first"
  ## policy in one feature.  Assuming all females plus males under 15
  ## got "dibs' on access to a lifeboat
  data$Boat.dibs <- "No"
  data$Boat.dibs[which(data$Sex == "female" | data$Age < 15)] <- "Yes"
  data$Boat.dibs <- as.factor(data$Boat.dibs)
  ## Family consolidates siblings and spouses (SibSp) plus
  ## parents and children (Parch) into one feature
  data$Family <- data$SibSp + data$Parch
  ## Fare.pp attempts to adjust group purchases by size of family
  data$Fare.pp <- data$Fare/(data$Family + 1)
  ## Giving the traveling class feature a new look
  data$Class <- data$Pclass
  data$Class <- revalue(data$Class, 
                        c("1"="First", "2"="Second", "3"="Third"))
  ## First character in Cabin number represents the Deck 
  data$Deck <- substring(data$Cabin, 1, 1)
  data$Deck[ which( is.na(data$Deck ))] <- "UNK"
  data$Deck <- as.factor(data$Deck)
  ## Odd-numbered cabins were reportedly on the port side of the ship
  ## Even-numbered cabins assigned Side="starboard"
  data$cabin.last.digit <- str_sub(data$Cabin, -1)
  data$Side <- "UNK"
  data$Side[which(isEven(data$cabin.last.digit))] <- "port"
  data$Side[which(isOdd(data$cabin.last.digit))] <- "starboard"
  data$Side <- as.factor(data$Side)
  data$cabin.last.digit <- NULL
  return (data)
}

## add remaining features to training data frame
df.train <- featureEngrg(df.train)
```

Now, pick a subset of features for use in the model building

```{r pickfeatures}
train.keeps <- c("Fate", "Sex", "Boat.dibs", "Age", "Title", 
                 "Class", "Deck", "Side", "Fare", "Fare.pp", 
                 "Embarked", "Family")
df.train.munged <- df.train[train.keeps]
````

To start developing a model, split model into a training and test batch (note we now have two test batches, one to develop the model, then one to test it afterwards).

```{r splitdata}
require(caret)
set.seed(23)
training.rows <- createDataPartition(df.train.munged$Fate,                                      p = 0.8, list = FALSE)
train.batch <- df.train.munged[training.rows, ]
test.batch <- df.train.munged[-training.rows, ]
```

First, let's try a logit model. This is a regression model that is used to classify.

```{r logittitanic}
Titanic.logit.1 <- glm(Fate ~ Sex + Class + Age + Family + Embarked + Fare, 
                       data = train.batch, family=binomial("logit"))
                       
Titanic.logit.1
```

See that the deviance was reduced by 951-631 = 320 points (null deviance is merely using the dominant result, which is not survive) using the logit model.

Let's try ANOVA to see if there is a way to improve this.

```{r}
anova(Titanic.logit.1, test="Chisq")
```

Fare does not seem to help here. Try to replace it with Fare.pp

```{r}
Titanic.logit.2 <- glm(Fate ~ Sex + Class + Age + Family + Embarked + Fare.pp,                        
                         data = train.batch, family=binomial("logit"))
Titanic.logit.2
anova(Titanic.logit.2, test="Chisq")
```

Not much better, let's just drop the fare.

```{r}
Titanic.logit.3 <- glm(Fate ~ Sex + Class + Age + Family + Embarked,                        
                         data = train.batch, family=binomial("logit"))
Titanic.logit.3
anova(Titanic.logit.3, test="Chisq")
```

```{r}
Titanic.logit.4 <- glm(Fate ~ Sex + Class + Age + Family + I(Embarked=="S"),                        
                         data = train.batch, family=binomial("logit"))
Titanic.logit.4
anova(Titanic.logit.4, test="Chisq")
```

Now, set up cross validation

```{r}
cv.ctrl <- trainControl(method = "repeatedcv", repeats = 3,
                        summaryFunction = twoClassSummary,
                        classProbs = TRUE)
```

Try Ada boosting

```{r}
require(ada)
ada.grid <- expand.grid(.iter = c(50, 100),
                        .maxdepth = c(4, 8),
                        .nu = c(0.1, 1))
set.seed(35)
ada.tune <- train(Fate ~ Sex + Class + Age + Family + Embarked, 
                  data = train.batch,
                  method = "ada",
                  metric = "ROC",
                  tuneGrid = ada.grid,
                  trControl = cv.ctrl)
ada.tune
```