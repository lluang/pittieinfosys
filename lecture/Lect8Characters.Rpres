Lecture 8: Character manipulation and Regular Expressions
========================================================
author: IE 0015 Information Systems
date: February 2015

Working with Characters
====================

-  For computers, working with numbers is easy.
-  Working with strings is harder.
-  Things to do
  -  Extract substrings
  -  Combine strings
  -  Match strings
  -  Search and replace
  
Basics of working with characters
==================

-  Character strings act much like arrays.
-  They can be sorted, determine length, etc.
-  The functions working with characters can be vectorized.
  - If you apply a function to a vector (array/data frame) it is applied to all members of that vector and the result is a vector.

```{r}
head(state.name)
length(state.name)
nchar(state.name)
```

Combining (concatenating) strings
==============

-  You can join strings
-  You can also combine variable values with strings
-  Specify how to separate strings using the `sep` parameter.

```{r}
cat("Long strings can", "be displayed over", "several lines using", "the fill= arguement", 
    sep = " ", fill = 40)
```

`paste` is a alternative to `cat`
=================

- Works when you need to convert other data types to strings
- Also better when you have to do operations to generate strings.

```{r}
paste(c('one', 2, 'three', 4, 'five'), 
      collapse = " ")
paste('X', 1:5, sep="")
paste(c('X', 'Y'), 1:6, sep="_", collapse="|")
```

Working with substrings
================

-  Computers treat strings like arrays, so getting a substring is like using indices of arrays.

```{r}
substring(state.name[1:5], 1, 4)
al = substring(state.name[1],first=1:nchar(state.name[1]), last=1:nchar(state.name[1]))
al
which(al=="a")
```

Replacing texts
==========

- We can use the substring function to replace strings if we find them
- Note that it overwrites, not expands the string

```{r}
nickname = "Sweet Home"
substring(state.name[1], 4, 4+nchar(nickname))=nickname
state.name[1]
``` 

Regular expressions
========
type: section

What are regular expressions?
===============

-  Regular expressions are ways of encoding patterns for matching sets of strings.
-  Find *x*
-  Find *x* but only if it occurs after *y*
-  Match *x*, but *x* can be written in many formats

Example - Phone numbers
======================

- How do you write a North American 10-digit phone number?
- e.g. 412-624-9830

Lets look for sets of digits
================

- `[0-9]` represents any character between 0 and 9, inclusive.
- *between* is based on the ASCII character set.
- Note that in RStudio, the *Find* bar includes a check box for *Regex*

With great power comes complexity
========================

-  Regular expressions attempts to be able to represent any type of search that can be imaginable.
-  But that means it needs to be able to represent very complex logic, and the results are complicated.
-  This is an example of a Domain Specific Language (DSL)

Preliminaries
========================

- Wildcards can match anything  ('.', '*')
- Backslashes ('\\') can be used to specify or ignore special behavior (e.g. I had to use two \ to represent one \ in between the quote marks in this sentence)
- References to *Perl* - A computer language whose main use was in working with text data. Includes an enhanced version of Regular Expressions from the POSIX standard. Use when available.

Basics
========

Regular expressions have three components

1.  literal characters
2.  character classes
3.  modifiers

Backslashes can be used to turn a modifier into a literal character.

Literal characters
=============

- Matched exactly

Character classes
=============

-  Letters [A-Z], [a-z], [A-Za-z]
-  Digits [0-9] [0123456789] \d
-  Other classes [ACTG]

Modifiers
===========

Modifier | Meaning |
-----|-----|
^ | beginning of target |
$ | end of target |
. | match any single character |
\| |  separates alternative patterns |
() | groups patterns together |
* | matches 0 or more of the preceding entity |
? | matches 0 or 1 of the preceding entity |
+ | matches 1 or more of the preceding entity |
{n} | matches exactly *n* occurrences of the preceding entity |
{n,} | matches at least *n* occurrences of the preceding entity |
{n, m} | matches between *n* and *m* occurrences of the preceding entity |

Examples
=========

- [0-9][0-9][a-zA-Z]+ has two digits followed by one or more letters.
- 12a 01Zd
- (abc){3} means abcabcabc
- \d{3}   Any group of three digits
- \D  Not a digit

Phone number
===========

- 412-624-9830
- (412) 624-9830
- \D?\d{3}\D+\d{3}\D?\d{4}
  - Optional leading character \D?
  - Three digits \d{3}
  - One or more non-digit \D+
  - Three digits \d{3}
  - Optional non-digit \D?
  - Four digits \d{4}

Splitting strings
=================

-  We can split strings based on a character or a regular expression.

```{r}
str = 'one   two      three  four'
strsplit(str, " ")
```

With regular expressions
==================

-  Use the one or more modifier '+' to say that any number of spaces will be a split

```{r}
strsplit(str, " +")
```

We can use it to find records in a data frame
================================

- *grep* takes a regular expression and a character string or vectors and returns either the indices or values (value=TRUE) of the matches
- Example, find women who are not members of nobility.
- Mrs, Miss, Ms, Mme (Madame), Mlle (Mademoiselle) are generic title for women and girls
- Always followed by a period in this database

```{r loadtitanic, echo=FALSE}
titanic <- read.csv("../data/titanictrain.csv")
```

```{r}
womentitanic <- (titanic[grep('Mrs\\.|Miss\\.|Ms\\.|Mme\\.|Mlle\\.',
                              titanic$Name), 
                         'Name'])
head(womentitanic)
length(womentitanic)
```

The Rime of the Ancient Mariner
==========================
type:section


The Rime of the Ancient Mariner, Coleridge (1798)
============

-  Copy this into a R-studio editor window and save to a file

```
THE RIME OF THE ANCYENT MARINERE, IN SEVEN PARTS.

ARGUMENT.

How a Ship having passed the Line was driven by Storms to the cold
Country towards the South Pole; and how from thence she made her course
to the tropical Latitude of the Great Pacific Ocean; and of the strange
things that befell; and in what manner the Ancyent Marinere came back to
his own Country.

I.

1      It is an ancyent Marinere,
2        And he stoppeth one of three:
3      "By thy long grey beard and thy glittering eye
4        "Now wherefore stoppest me?
```



Working with text within R
========================

-  Read text into a variable
-  Find patterns using `grep`

```{r}
rime.txt <- file("../data/rime-intro.txt")
rime <- scan(rime.txt, what=character(), sep='\n')
any(grep('ship',rime))
any(grep('Ship',rime))
any(grep('[Ss]hip',rime))
```

Better will be to find all examples and where they are
=====================

-  `regexpr` finds the first match in each section of the text.
-  `gregexpr` finds all matches in each section of text.

```{r}
regexprresult <- regexpr('Marinere', rime)
regexprresult
gregexprresult <- gregexpr('Marinere', rime)
gregexprresult
```

Matching non-digits
=========

-  *Character classes* also known as *conventions* have been created to express different groups of characters

-  [\d] refers to any digit. Same as [0-9]
-  [\D] is any non-digit. Same as [^0-9] or [^\d]
-  [\w] is any word character. Same as [_a-zA-Z0-9]
  - Does NOT include white space (tabs, new lines, punctuation)
-  [\W] is any non-word character (whitespace, punctuation, etc). Same as [^_a-zA-Z0-9]
-  [\s] or [ \t\n\r] matches whitespace, or
  - spaces
  - [\t] tabs
  - [\n] newlines
  - [\r] carriage returns

Examples of using character classes in R
=========

-  Note the double backslash. First backslash is to tell R that the second one is real and not an escape sequence.

```{r}
regexpr('\\d', rime)
gregexpr('\\D', rime)
gregexpr('\\w', rime)
regexpr('\\W', rime)
gregexpr('[A-Z]', rime)
```

Alternatives
==================

- What if you wanted to match alternative spellings?
- '|' is used to separate alternatives

```{r}
regexpr('[t|T][h|H][e|E]', rime)
gregexpr('(the|The|THE)', rime)
```

More character classes
==================

```{r}
characters = "! \" # $ % & ' ( ) * + , - . /
0       1       2       3       4       5       6       7       8       9
: ; < = > ? @
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
[ \ ] ^ _ `
a b c d e f g h i j k l m n o p q r s t u v w x y z
{ | } ~"
```

Look for a specific class
============
```{r}
gregexpr("[aeiou]", characters)
```

Or everything else
==============
```{r}
gregexpr("[^aeiou]", characters)
```

Try groups of characters
=====================

```{r}
gregexpr("[0-3]", characters)
gregexpr("[6-9]", characters)
```

Combine them
=====
```{r}
gregexpr("[0-36-9]", characters)
```

Unicode characters are often used for non-standard characters
============
```{r}
basho.txt <- file("../data/basho.txt")
basho <- scan(basho.txt, what=character(), sep='\n')
basho
```

Searching for unicode characters
=============

-  Include a '\u' in front of the 4-digit unicode number
```{r}
regexpr("\u6c60", basho)
```

Some punctuation characters are also unicode characters
===============

-  What do these find?
-  \u2014
-  \u2013
```{r}
regexpr("\u2014", basho)
regexpr("\u2013", basho)
basho
```

Lookarounds
=========

- We can look for words in combination.
- Let's look for "Marinere", but only if it is preceded by "Ancyent"
- Make it case insensitive by using `(?i)` (and set `perl=TRUE`)
- Note that the `ancyent` was matched, not the lookahead part (`marinere`) (see the length of the match)
- We'll use the full Rime of the Ancyent Mariner text

```{r}
rimefull.txt <- file("../data/rime.txt")
rimefull <- scan(rimefull.txt, what=character(), sep='\n')
getAncyentMariner <- function(data, regexpression) {
  string.start <- regexpr(regexpression, data, perl=TRUE)
  string.end <- string.start+ attr(string.start, "match.length")-2
  target <- substr(data, string.start, string.end)
  return (target)
}  
findancyentmariner <- getAncyentMariner(rimefull, "(?i)ancyent (?=marinere)")
head(findancyentmariner, n=30)
```
Let's be more flexible on what we find
==============

```{r}
findancyentma <- getAncyentMariner(rimefull, "(?i)ancyent (?=ma*)")
head(findancyentma, n=30)
```

Negative lookahead
======
- Same pattern, but make sure that the pattern does not appear immediate after the first
- `?!` (remember that `!` means NOT)

```{r}
findancyentnomariner <- getAncyentMariner(rimefull, "(?i)ancyent (?!marinere)")
head(findancyentnomariner, n=30)
```

Lookbehind
========

-  Same thing, but look backwards using `?<='

```{r}
findancyentbeforemariner <- getAncyentMariner(rimefull, "(?i)(?<=ancyent) marinere")
head(findancyentbeforemariner, n=30)
```
```{r}
findmariner <- getAncyentMariner(rimefull, "(?i)marinere")
head(findmariner, n=30)
```