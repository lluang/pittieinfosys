Lecture 11 Reshaping data
========================================================
author: IE 0015 Information Systems
date: March 2015


```{r loadlibraries, echo=FALSE, warning=FALSE}
library(reshape)
library(plyr)
FemPreg <- read.csv("../data/2006_2010_FemPreg.csv",
                    header=TRUE, sep=",")
```
```{r readingsqlite, echo=FALSE, warning=FALSE}
library(RSQLite)
con <- dbConnect(SQLite(), "../data/acs1yrPittsburgh01701.sqlite")
sql <- "SELECT *      
        FROM ss12hpa"
acsh <- dbGetQuery(con, sql)
sql <- "SELECT *      
        FROM ss12ppa"
acsp <- dbGetQuery(con, sql)
```


Why is reshape necessary
==============

1.  In many cases, the question you have is not directly addressed by the data that was collected.
  - The data was collected for a different purpose.
  - The actual collection of the data was designed for the ease of the data collector.
2.  Many mathematical and statistical functions are designed with a specific format of the data.
  - It is your job to make the data fit the format required.

Reshaping data frames
=============
-  Because data frames are so useful in data analysis, many packages are designed to work with data frames.
-  `reshape` is used to convert a data frame into what is desired before applying a function to it.
-  Data frames are a list of vectors (so remember how to access lists, and remember how to access vectors)



  

Modifying data frame variables
===============

-  Data frames are lists (of vectors)
-  New values can be created by creating a new column to the data frame.
  - i.e. add a new vector to the list of vectors.

```{r incomepercapita}
acsh$percapita <- as.numeric(acsh$HINCP)/as.numeric(acsh$NP)
```

or

```
acsh['percapita]' <- as.numeric(acsh['HINCP'])/as.numeric(acsh['NP'])
```

Removing a column
============

- We can remove a column by replacing it in the list with `NULL`
- Usually, it is more useful to set certain values to `NULL` or `NA` or to create a new data frame that has only the values you are interested in.


```{r subsetchildren}
head(acsh$percapita)
acsh$percapita <- NULL
head(acsh$percapita)
acsnoinsurance <- subset(acsp, HICOV==2)
head(acsnoinsurance[c('HINS1', 'HINS2', 'HINS3', 'HINS4', 'HINS5', 'HINS6', 'HINS7')],)
```

Recoding values
=========

-  We may want to create new variables based on values of an old variable.
-  e.g. encoded in data as a number (0,1), we want to use text or TRUE/FALSE, for reporting.
  - Note: statistics programs are more efficient with numbers or Boolean, so convert to text after analysis if possible.

Recoding through logical variables
================

-  We have a condition we want to select on.
-  Use a logical expression. Automatically creates a logical vector.

```{r}
below50K <- acsh$HINCP < 50000
head(below50K)
typeof(logical)
```

Recoding to categories using logical variables
=============

- Note that TRUE >- 1 and FALSE -> 0 so it is possible to create multiple levels this way.

```{r}
incomegroup <- 0 + (acsh$HINCP > 20000) +
                   (acsh$HINCP > 50000) +
                   (acsh$HINCP > 75000) +
                   (acsh$HINCP > 100000)
head(incomegroup)
```

Another way to categorize using cut
==============

-  We can also use the `cut` function.

```{r}
incomegroup2 <- cut(as.numeric(acsh$HINCP), c(0, 20000, 50000, 75000, 100000),
                   include.lowest=TRUE, right=FALSE)
head(incomegroup2)
```

ifelse statements work for this purpose
===========

-  `ifelse(condition, conditiontrue, conditionfalse)`

```{r}
hiincome <- ifelse(incomegroup %in% c(3,4), 1, 0)
head(hiincome)
```

-  Note: `ifelse` can be inefficient because the results of both conditions need to be evaluated for every element in the condition vector.

```{r}
hiincome2 <- sapply(incomegroup, function(incomegroup) if (incomegroup %in% c(3,4))  1 else 0)
head(hiincome2)
```

Recoding with multiple outcomes
============

- Two other functions to recode data are
-  `recode`, part of the `car` package
-  `mapvalues`, part of the `plyr` package

car::recode
======

- `recode` in `car` accepts descriptions of ranges, then applies them to data to determine a new value.
-  Four types of ranges

1.  Single value - '1' = "Mortgage"
2.  Multiple values - c(3,4) = 1
3.  Ranges of values - 3-5 = 'High'
4.  Anything not covered - `else`


Housing tenure
=======

```{r}
library(car)
homeownership <- recode(acsh$TEN, 'c(1,2)= "Own"; 3="Rent"; else="Occupied"')
head(homeownership)
```

Reshaping
========

-  We covered this last week.
-  We can take a data frame (list of vectors) and `stack` the vectors on top of each other.
-  Or a vector of values and a vector of factors and `unstack` them to get a list of vectors.
-  We can use `plyr::reshape` to `melt` data so that it is *long*, or `cast` data so that it becomes *wide*.
-  One reason to use this is if data is provided in columns of groups, but we want to plot them together.
  -  i.e. instead of separate columns that happen to be together, create a single data frame that has factors so we can use `qplot` or `ggplot`.

Example of groups as columns
========

```{r}
mydata = data.frame(grp1=c(12,15,19,22,25),
                    grp2=c(18,12,42,29,44),
                    grp3=c(8,17,22,19,31))
mydata
```

Stack the vectors
====

-  `stack` takes a list of vectors and creates a single vector alongside a factor variable

```{r}
sdata = stack(mydata)
sdata
```

Unstack
=====
-  `unstack` takes a vector of values and a vector of factor values and breaks them into separate columns

```{r}
mydata2 <- unstack(sdata, values~ind)
mydata2
```

reshape
=======

- `reshape` is more flexible (part of the base `stats` package, does not have to be reloaded)
-  Use this when the data is not readily organized into a list of vectors.
-  E.g. the same observation has several different measurements made.
-  Some random data

```{r}
set.seed(17)
obs = data.frame(subj=rep(1:4,rep(3,4)),
                            time=rep(1:3),
                            x=rnorm(12),y=rnorm(12))
head(obs)
```

Using reshape
=====
```{r}
wideobs <- reshape(obs, idvar='subj', v.names=c('x','y'),
                   timevar = 'time', direction='wide')
wideobs
```
-  We now have three pairs of variables for each subject.
-  Representing the three time each subjects had observations made.

Convert back to original
========

-  How the `reshape` was done is preserved in the new data frame.
-  Reverse the procedure by running `reshape` with no arguments.
```{r}
obs2 <- reshape(wideobs)
obs2
```


Combining data frames
=====================

-  Data frames are lists of vectors
-  Sometimes we can get data from two different sources, but with either 
  -  The same data, but different subjects, or
  -  The same subjects, but different data
-  Combine data frames using `rbind` or `cbind`

Combining same data on different subjects
======================

-  Scenario: you have the same data elements, but the two files refer to different observations.
-  Want to combine the two by adding rows
-  `rbind`
-  Data frames must have the same number of columns (and they should be matcehd to each other)

Using rbind
======================




Split-apply-combine
============

-  A common data analysis pattern.
  -  `pattern` - A structure that is used to approach types of problems
  -  Originated in architecture, often used in fields that involved developing and implementing creative solutions.
-  Break up a problem into manageable pieces.
-  Operate on each piece independently.
-  Re-combine the pieces with the results.
-  e.g. calculating marginal statistics based on grouping the data based on a factor.