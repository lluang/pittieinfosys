---
title: 'Lecture 5: Data Aggregation'
author: "IE 0015 Spring 2018"
date: "February 2018"
output:
  pdf_document: default
  html_document: default
  slidy_presentation: default
---

Note: You will need ACS data. Because this is R, you can use either the Allegheny County North or Pennsylvania data sets with no problem.

Functional programming
=========

- In data analysis, one of the most common tasks is to perform an operation on every line.
- When this is done, every line's operations is independent of every other line.
- This is a tenent of functional programming (as opposed to procedural programming (what you learned in Matlab or C)) or object oriented programming (if you learned objects in C++).
- The focus is on performing an action on data (functions are verbs) as opposed to identifying objects and their attributes and capabilities (objects are nouns with member attributes and member functions.)

Aggregating data
================

-  We often want to look at summarized data across groups, not individual data points.
-  e.g. count instances, summations
-  `table` function accomplishes this goal.
-  `apply` family of functions can be used to work on arrays or lists.
-  Sometimes, we can do things using the `group_by` and `summarize` functions from `dplyr`. This is for when those do not work (e.g. there is a function we need to use that does not work with `summarize`)

Issues
======

-  Aggregating data hides information in the data, so typically do this after you have determined what aggregation is useful.
-  We aggregate to reduce the number of dimensions being presented, so do this because there are more dimensions to be analyzed than can be understood easily.
-  Aggregation is done because you have something that needs to be communicated and you are attempting to remove extra detail through summaries.  Make sure that what is removed is extra.

>  Everything should be a simple as possible, but no simpler.
>       - Einstein (paraphrase)



table
=====

-  Creates an array of values and counts
-  Can be turned into a `data.frame`

Use ACS as an example
============

```{r}
library(tidyr)
library(dplyr)
library(magrittr)

acsh <- read.csv("../data/ss12hpa.csv")
acsp <- read.csv("../data/ss12ppa.csv")
```

table summaries
=================

- the `table` function creates a formatted summary output of a list.
- Look at travel arrangements

```{r}
carpool <- acsp$JWRIP
cptable <- table(carpool)
cptable
```

Or make the table summary a data frame
==================

```{r}
as.data.frame(cptable)
```


Diversion:  recode variables
=======================

- In the ACS data, many of the variables are coded as integers ("1", "2", "3", etc)
- We would want to recode them with their values in English
- Use ``merge`` to do an operation similar to join


```{r}
worktransportation = data.frame(
              JWTR = as.factor(c("bb", "01", "02", "03", "04", "05", "06",
                     "07", "08", "09", "10", "11", "12")), 
              worktransportation = c(NA, 
                    "Car, truck, or van",
                    "Bus or trolley bus",
                    "Streetcar", "Subway",
                    "Railroad", "Ferryboat",
                    "Taxicab", "Motorcycle",
                    "Bicycle", "Walked",
                    "Worked at home", "Other"))

acsp$JWTR <- as.factor(acsp$JWTR)
acsp1 <- acsp %>% left_join(worktransportation, by='JWTR')
commutetable <- table(acsp1$worktransportation)
as.data.frame(commutetable)
```


Thinking about aggregation
========================

-  What are the groups that are useful to aggregate on?
-  What is the nature of data to be operated on?
-  What is the desired end result.

dplyr group_by and summarize
=============================

- Use `group_by` and `summarize` to create data summaries
- Apply a summary function for each group defined by `group_by`
- Center:  `mean()`, `median()`
- Spread:  `sd()`, `IQR()`
- Range: `min()`, `max()`, `quantile()`
- Position:   `first()`, `last()`, `nth()`
- Count: `n()`, `n_distinct()`
- Logical: `any()`, `all()`


Look at housing tenure
==============

```{r}
# Mean household income split by housing Tenure
tenurevalues <- data.frame(
                  TEN = c("", "1", "2", "3", "4"), 
                  tenurevalues = c(NA, 
                                 "Owned with mortgage or loan",
                                 "Owned free and clear",
                                 "Rented",
                                 "Occupied without payment of rent"))
acsh$TEN <- as.factor(acsh$TEN)
acsh <- acsh %>% left_join(tenurevalues, by='TEN')
acsh$watercost <- as.numeric(acsh$WATP)
acsh$householdincome <- as.numeric(acsh$HINCP)
acsh$numpeople <- as.numeric(acsh$NP)
```

Mean income
==========

```{r}
acsh %>% group_by(tenurevalues) %>%
  summarise(meanincome = mean(householdincome, na.rm=TRUE))
```

More summary examples
=====================
```{r}
acsh %>% group_by(tenurevalues) %>%
  summarise(numberhouseholds = n(),
            meanincome = mean(householdincome, na.rm=TRUE),
            medianincome = median(householdincome, na.rm=TRUE),
            sdincome = sd(householdincome, na.rm=TRUE),
            minincome = min(householdincome, na.rm=TRUE),
            maxincome = max(householdincome, na.rm=TRUE),
            nintyfifthquant = quantile(householdincome, probs = 0.95, na.rm=TRUE))
```


The `apply` family of functions
=============================

-  In programming languages that have functional features (e.g. R, Matlab), we generally do not use `for` loops to loop through data.
-  If data is organized in a matrix, array, or vector, we can **map** a function to the data structure.
-  Apply the function to each element in the data structure.

The `for loop` counterpart
==========================

- If you cannot get this to work, but you remember how to do `for loops`, you can do the same by:
  - creating an empty list to save the results
  - Write a for loop that iterates through the data and appends an element for each row of data.

```{r}
# create a matrix of 10 rows x 2 columns
m <- matrix(c(1:10, 11:20), nrow = 10, ncol = 2)
# mean of the rows, 
rowmean <- c()
for (i in 1:dim(m)[1]){
  rowmean <- append(rowmean, mean(m[i,]))
}
rowmean
```



Some members of the apply family of functions
===========================

Function name  | Description
--------------------|------------------
apply  |  Apply function over array margin
by     | Apply function to a data frame split by factors
lapply | Apply function over a list or vector (returns list)
sapply | Apply function over a list or vector (returns vector or matrix)
aggregate | Summaries over columns of a data frame.
tapply | Apply function over a ragged array

apply: 
=======

-  Apply function over array margins
-  *Margins* are the dimensions of the array (row = 1, columns = 2)

```{r}
# create a matrix of 10 rows x 2 columns
m <- matrix(c(1:10, 11:20), nrow = 10, ncol = 2)
# mean of the rows
apply(m, 1, mean)
# mean of the columns
apply(m, 2, mean)
# divide all values by 2
apply(m, 1:2, function(x) x/2)
```

by: data frame split by factors
======

-  Summarize data frame split by factors

Results of grouping by a factor
=====
```{r}
by(acsh[,c('householdincome', 'numpeople', 'watercost')], acsh$tenurevalues, colMeans)
```

lapply
======
- Returns a list resulting from applying a function to the corresponding element of X

```{r}
# create a list with 2 elements
l <- list(a = 1:10, b = 11:20)
# the mean of the values in each element
l.mean <-lapply(l, mean)
typeof(l.mean)
l.mean[['a']]
```

sapply
======

- like `lapply` but returns a vector or matrix

```{r}
l.mean <- sapply(l, mean)
typeof(l.mean)
l.mean['a']
l.mean[1]
```

vapply
======

- `vapply` is similar to `sapply`, but has a prespecified type of return value.
- e.g. `fivenum` returns a summary of min, 1Q, median, 3Q, max

```{r}
l.fivenum <- vapply(l, fivenum, c(Min.=0, "1st Qu."=0, Median=0, "3rd Qu."=0, Max.=0))
class(l.fivenum)
l.fivenum
```

mapply
======

-  Multivariate version of `sapply`.  Applies the function to the first elements of each arguement, second element, etc.

```{r}
l1 <- list(a = c(1:10), b = c(11:20))
l2 <- list(c = c(21:30), d = c(31:40))
# sum the corresponding elements of l1 and l2
mapply(sum, l1$a, l1$b, l2$c, l2$d)
```


Groups based on one or more group variables
==============

- `aggregate`
- `tapply`

aggregate
==========

-  Summarize a columns based on defined groups

```{r}
library(reshape2)
library(ggplot2) #loads reshape2 package
summary(diamonds)
aggregate(diamonds[,c(1, 7)], diamonds[,c(2,3)], mean) %>% head()
```

tapply
======

-  Processes a single vector based on the values of one or more grouping vectors

```{r}
maxcarat <- tapply(diamonds$carat, diamonds$color, max)
maxcarat
```
Mapping a function to a vector or list
====================

- `lapply` - Returns output as a list
-  `sapply` - returns output as a vector or matrix (if possible)
-  `apply` allows choice of axis over a matrix. Returns a matrix
-  Note: returning a vector implies that order is important, e.g. the results are matched to another vector.

Example for a mapping
=============

-  Break out individual words for each sentence.
-  Unknown number of words in each sentence, so use a row for each sentence.

```{r}
library(stringr)
text = c("R is a free environment for statistical analysis",
 "It compiles and runs on a variety of platforms",
 "Visit the R home page for more information")
result = str_split(text, " ", simplify=TRUE)
result
```

Now, take the matrix and get the length of each sentence
==================

- Because we want the length to be associated with the rows, use `apply` and `MARGIN=1` (rows)

```{r}
nwords = apply(result, MARGIN=1, FUN=length)
nwords
```

Mapping a function to a matrix or array
=====================

-  Because we often do analysis based on each element in a data frame, we often use `apply` on data frames.
-  Income per family member
-  Note that we are passing in a data frame (which is a list of lists (of columns)) and getting a list back (which we add as a column in the data frame.)

```{r}
familypercapita <- function(acs){
  percapita <- as.numeric(acs[["HINCP"]])/as.numeric(acs[["NP"]])
}
acsh$FINCP <- as.numeric(acsh$FINCP)
acsh$HINCP <- as.numeric(acsh$HINCP)
acsh$NP <- as.integer(acsh$NP)
acsh$percapita <- apply(acsh, 1, familypercapita)
summary(acsh$percapita)
```


Mapping a function based on groups
=====

-  `aggregate`  for data frames
-  `tapply` for vectors


Introduction
============

- 80% of data analysis is spent on the process of cleaning and preparing data.
- Tidy data provides a standard way to organize data values within a data set.
- Standard facilitates initial exploration and analysis of data.
- Simplifies the development of data analysis tools that work well together.
  - You do not have to take the output of one tool, then manipulate it into the input of the next.
- Understanding tidy data should also improve your spreadsheets.
  - Design your spreadsheets knowing that you will use it as a data source in addition to an analysis tool.

Where data manipulation fits in the workflow
=======================
![Data analysis workflow](figures/data-science-communicate.png)

Relationship to databases
=========================

- Tidy data is similar to Codd's normal forms in relational algebra and relational databases.
  - This is covered this in IE 1014 Database design.
- Presentation is focused on the need to make data analysis tools work together.


Definitions
==================

- Most statistical datasets are rectangular tables made up of *rows* and *columns*.
- A dataset is a collection of values
  - Each value belongs to an *observation* and *variable*
  - A *variable* contains all values that measure the same underlying attribute across observational units.
  - An *observation* contains all values measured on the same unit.
- A *tibble*  is an immutable data frame 
  - *immutable* cannot be changed. This is an aspect of functional (as opposed to procedural or object oriented) programming. You can use a data frame where R4DS says tibble.

Tidy data rules
==========

1.  Each variable must have its own column.
2.  Each observation must have its own row.
3.  Each value must have its own cell.

Implications
===========

1. Put each dataset has its own data.frame.
2. Put each variable in a column.

Benefits to tidy data
=====================

1.  Having one consistent way of storing data leads you to learn a standard set of tools and methods to work with them (i.e. patterns)
2.  If variables are in columns, then you can use vectorized methods. (vectorized methods are a hallmark of data focused programming environments like R, Matlab, and Python)
3.  The R packages you will learn this semester (ggplot2, dplyr) are designed to work with tidy data.

Introduction to R
=================

- R is a data analysis environment.
- Includes the tools for working with data using data frames.
- Anything that you can do in a database, you can do with a data frame.
- Usually, the reason you use a database is to ensure data integrity and availability.

Data types in R
===============

- R tries to automatically recognize data types, but you can tell R that a data frame variable is of a specific data type.
- as.integer()
- as.double()
- as.character()
- as.factor()
- as.ordered()

```{r, echo=FALSE}
library(tidyr)
library(dplyr)
```

Three versions of a table, what makes it not tidy?
- Country, year, population, cases

Version 1
===========
```{r, echo=FALSE}
table2
```

Version 2
==========
```{r, echo=FALSE}
table3
```

Version 3
==========
```{r, echo=FALSE}
table4a
```
```{r, echo=FALSE}
table4b
```

Version 4
=========
```{r, echo=FALSE}
table1
```

Benefits - Vectorized operations %>% operator
=================================

- %>% (pipe) operator works on each row of a data frame.
- Take something on the left side and perform the function on the right side to each element.
- Alternative - ???

```{r}
table1 %>% 
  mutate(rate = cases / population * 10000)
```

Why may data be provided in other forms?
===========================

- Data may be organized for another purpose? e.g. making collection easy.
- People who do not work with data may not appreciate the need to make it easy.

Ways data may be badly organized
============================

- There may be a variable spread among multiple columns (e.g. class1, class2, class3)
- One observation may be spread among multiple rows.

Basic operations to correct this
=================================

- *gather* - Column names are actually values not variables, need to break them into rows of individual values.
- *spread* - One observation is on multiple rows, collect rows and use columns to hold variables.
- use the package `tidyr` (part of `tidyverse`)

Gather
===========

- Take a table where values are spread over two columns
- Create rows that give a year and number of cases.
- Columns should be: Country, year, cases
```{r}
table4a
```

gather()
========
```{r}
help(gather)
```


using gather
===========
```{r}
 head(gather(table4a, `1999`, `2000`, key = "year", value = "cases"),6)
```

Same thing using pipes
============
```{r}
table4a %>% gather(`1999`, `2000`, key = "year", value = "cases") %>% head(6)
```

Do the same thing with the population table and save the results
=================

```{r}
tidy4a <- table4a %>% gather(`1999`, `2000`, key = "year", value = "cases") %>% head(6)
tidy4b <- table4b %>% gather(`1999`, `2000`, key = "year", value = "population")
```
```{r}
tidy4b %>% head(4)
```

With tidy data, now other operations become easier
================

- We will cover relational operations in the next lecture.

```{r}
tidy4 <- left_join(tidy4a, tidy4b, by=c('country', 'year'))
head(tidy4, 4)
```

Spread
=======

- Data on a single observation is spread on two rows.
- Often used to make data readable on a single sheet of paper.
- You need to combine rows for a single observation into a single row.

Example
=====

- For each country and year, have cases and population.
- Then you can easily calculate a rate or proportion of population.
```{r}
table2%>% head(4)
```

Using spread
==========

- Key is the column with the variable names (which were split into different rows)
- Value is the column with the value of the variable for that observation.

```{r}
help(spread)
```

spread
========
```{r}
tidy2 <- table2 %>% spread(key=type, value=count)
tidy2 %>% head(4)
```

Separate
========

- Separate is when two values are kept in a single column.
- Often seen in Excel spreadsheets where 2 values are put in a single cell to mimic a table.
- `separate` will split on a non-alpha numeric character

```{r}
help(separate)
```

Separate example
========


```{r}
table3 %>% head(2)
```

===========
```{r}
tidy3 <- table3 %>% separate(col='rate', into=c('cases', 'population'), sep='/')
head(tidy3, 4)
```



Returning multiple values
==========================

- In most programming languages, a function can return one value.
- To get around this, you can return a data structure
  - e.g. in C, you can create and return a `struct`
  - In R, you generally return a list of values
  
```{r}
# create a matrix of 10 rows x 2 columns
m <- matrix(c(1:10, 11:20), nrow = 10, ncol = 2)
doublehalfsumrow <- function(element){
  doublerow <- sum(element)*2
  halfrow <- sum(element)/2
  c(doublerow, halfrow)
}
mframe <- data.frame(col1 = m[,1], col2 =m[,2])
rowreturn <- apply(m, 1, doublehalfsumrow)
mframe$doublerow <- rowreturn[1,]
mframe$halfrow <- rowreturn[2,]
mframe
```
